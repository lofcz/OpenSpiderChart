<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ngon = 3;
len  = 50;
times = 5;
fillAll = false;
color = vec3(0, 0, 255);
colorMode = 0;

maxValue = 1000;
for (var i = 0; i &lt; 20; i++)
    {
     val[i] = irandom_range(1, 10) * 100;
     dVal[i] = val[i];
     bVal[i] = val[i];
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Raw gml solution
/*
var angle = 0;
var tempLen = len;

for (var j = 0; j &lt; times; j++)
{ 
for (var i = 0; i &lt; ngon; i++)
    {
     var retArray = draw_line_angle(x, y, tempLen, angle, 3);
     if (i == 0) {var startArray = retArray;}
     angle += (360 / ngon);
     
     if (i &gt; 0) 
        {
         draw_line(retArray[0], retArray[1], prevArray[0], prevArray[1]);
         if (i == ngon - 1) {draw_line(retArray[0], retArray[1], startArray[0], startArray[1]);}
        }
        
     if (j == times - 1)
        {    
        var oX = cos(degtorad(angle)) * (25);
        var oY = sin(degtorad(angle)) * (25);
        
        draw_text(retArray[0] + oX, retArray[1] + oY, string(i));
        
        draw_set_color(c_red);
        var tempX = x + cos(degtorad(angle)) *  dVal[i] / maxValue * (tempLen);
        var tempY = y + sin(degtorad(angle)) *  dVal[i] / maxValue * (tempLen);
        
        if (i == 0) {startX = tempX; startY = tempY;}

        draw_set_color(c_black);        
        if (i &gt; 0)
           {
            draw_set_color(c_red);
            draw_set_alpha(0.5);
            draw_triangle(x, y, tempX, tempY, prevTempX, prevTempY, false); 
            if (i == ngon - 1) {draw_triangle(x, y, tempX, tempY, startX, startY, false);}
            draw_set_color(c_black);
            draw_set_alpha(1);
           }
         
        prevTempX = tempX;
        prevTempY = tempY; 
        }
        
     var prevArray = retArray;          
    }
tempLen += len;
}  

for (var i = 0; i &lt; array_length_1d(val); i++)
    {
     if (fillAll) {val[i] = maxValue;}
     dVal[i] = lerp(dVal[i], val[i], 0.1);
    }
    
if (mouse_check_button_pressed(mb_left))   {ngon++; val[ngon] = irandom_range(1, 10) * 100; dVal[ngon] = val[ngon];}
if (mouse_check_button_pressed(mb_right)) {var index = irandom_range(0, ngon - 1); val[index] += 100; val[index] = clamp(val[index], 0, maxValue);}
if (mouse_check_button_pressed(mb_middle)) {fillAll = !fillAll;}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// SGML solution
/*
var angle   = 0;
var tempLen = len;

for (var j = 0; j &lt; times; j++)
{ 
for (var i = 0; i &lt; ngon; i++)
    {
     var vec = draw_line_angle_vec(x, y, tempLen, angle, 3);
     if (i == 0) {var startVec = vec;}
     angle += (360 / ngon);
     
     if (i &gt; 0) 
        {
         draw_line(vec2GetX(vec), vec2GetY(vec), vec2GetX(prevVec), vec2GetY(prevVec));
         if (i == ngon - 1) {draw_line(vec2GetX(vec), vec2GetY(vec), vec2GetX(startVec), vec2GetY(startVec));}
        }
        
     if (j == times - 1)
        {    
        var oX = cos(degtorad(angle)) * (25);
        var oY = sin(degtorad(angle)) * (25);
        
        draw_text(vec2GetX(vec) + oX, vec2GetY(vec) + oY, string(i));
        
        clr(c_red);
        var tempX = x + cos(degtorad(angle)) *  dVal[i] / maxValue * (tempLen);
        var tempY = y + sin(degtorad(angle)) *  dVal[i] / maxValue * (tempLen);
        
        if (i == 0) {startX = tempX; startY = tempY;}

        clr(c_black);        
        if (i &gt; 0)
           {
            clr(c_red, 0.5);
            draw_triangle(x, y, tempX, tempY, prevTempX, prevTempY, false); 
            if (i == ngon - 1) {draw_triangle(x, y, tempX, tempY, startX, startY, false);}
            clr();         
           }
         
        prevTempX = tempX;
        prevTempY = tempY; 
        }
        
     var prevVec = vec;          
    }
tempLen += len;
}  

for (var i = 0; i &lt; array_length_1d(val); i++)
    {
     if (fillAll) {val[i] = maxValue;}
     dVal[i] = lerp(dVal[i], val[i], 0.1);
    }
    
if (mouse_check_button_pressed(mb_left))   {ngon++; val[ngon] = irandom_range(1, 10) * 100; dVal[ngon] = val[ngon];}
if (mouse_check_button_pressed(mb_right))  {var index = irandom_range(0, ngon - 1); val[index] += 100; val[index] = clamp(val[index], 0, maxValue);}
if (mouse_check_button_pressed(mb_middle)) {fillAll = !fillAll;}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Output code

var angle   = 0;   // Current angle of triangle being drawn
var tempLen = len; // Temp width of chart

// Draw web n times, increasing size
for (var j = 0; j &lt; times; j++)
    { 
     //  Draw basic polygon structure
     for (var i = 0; i &lt; ngon; i++)
         {
          var vec = draw_line_angle_vec(x, y, tempLen, angle, 3); // Store draw end point to vec2(x, y)
          if (i == 0) {var startVec = vec;} // Needed to draw the last rectangle as (x, y, tX, tY, fX, fY)
          angle += (360 / ngon); // Total angle to be rotated is 2pi rad
     
          // In case we already have location of the first point, connect two lines together
          if (i &gt; 0) 
             {
              //draw_line(vec2GetX(vec), vec2GetY(vec), vec2GetX(prevVec), vec2GetY(prevVec)); // Connection line
              //if (i == ngon - 1) {draw_line(vec2GetX(vec), vec2GetY(vec), vec2GetX(startVec), vec2GetY(startVec));} // Join last and first line
             }
          
          // In case of the last iteration, draw values and notes
          if (j == times - 1)
             {    
              var oVec = vec2(cos(degtorad(angle)) * 25, sin(degtorad(angle)) * 25); // Offset vector, needed to draw text to the right location    
              draw_text(vec2GetX(vec) + vec2GetX(oVec), vec2GetY(vec) + + vec2GetY(oVec), string(i)); // Temp note, insert block name here                                                              [PLACEHOLDER]
        
              clr(c_red); // Set draw color to red and alpha to 1
              var tempVec = vec2(x + cos(degtorad(angle)) *  dVal[i] / maxValue * (tempLen), y + sin(degtorad(angle)) *  dVal[i] / maxValue * (tempLen)); // Compute draw location of the value       
              if (i == 0) {var sVec = tempVec;} // Needed to connect first and last point

              clr(c_black); // Set draw color to black and alpha to 1    
              
              // In case we already know location of the first point, map values to trinagles    
              if (i &gt; 0)
                 {
                  clr(make_colour_rgb(vec3GetX(color), vec3GetY(color), vec3GetZ(color)), 0.5); // Set draw color and alpha to 0.5
                  draw_triangle(x, y, vec2GetX(tempVec), vec2GetY(tempVec), vec2GetX(lastVec), vec2GetY(lastVec), false); // Draw triangle as (xy, actualPoint, prevPoint) 
                  if (i == ngon - 1) {draw_triangle(x, y, vec2GetX(tempVec), vec2GetY(tempVec), vec2GetX(sVec), vec2GetY(sVec), false);} // Draw triangle connecting first and last point
                  clr(); // Reset draw color and alpha (black, 1)  
                 } 
              var lastVec = tempVec; // Store actual point to previous point
             }        
           var prevVec = vec; // Store actual vector to previous vector       
          }
     tempLen += len; // Increase size of the web
    }  

// Interpolate drawn values to the real values
for (var i = 0; i &lt; array_length_1d(val); i++)
    {
     if (fillAll) {val[i] = maxValue;} // In case fillAll mode has been activated set all real values to max
     if (fillAll == -1) {val[i] = bVal[i];}
     dVal[i] = lerp(dVal[i], val[i], 0.1); // Linear interpolation of the iterated value
    }
    
// Interpolate color
if (colorMode == 0) {vec3SetX(color, lerp(vec3GetX(color), 255, 0.1)); vec3SetY(color, lerp(vec3GetY(color), 0, 0.1)); vec3SetZ(color, lerp(vec3GetZ(color), 0, 0.1)); if (vec3GetX(color) &gt; 254) {colorMode = 1;}}
if (colorMode == 1) {vec3SetY(color, lerp(vec3GetY(color), 255, 0.1)); vec3SetX(color, lerp(vec3GetX(color), 0, 0.1)); vec3SetZ(color, lerp(vec3GetZ(color), 0, 0.1)); if (vec3GetY(color) &gt; 254) {colorMode = 2;}}
if (colorMode == 2) {vec3SetZ(color, lerp(vec3GetZ(color), 255, 0.1)); vec3SetX(color, lerp(vec3GetX(color), 0, 0.1)); vec3SetY(color, lerp(vec3GetY(color), 0, 0.1)); if (vec3GetZ(color) &gt; 254) {colorMode = 0;}}



// Controll    
if (mouse_check_button(mb_left))   {ngon++; val[ngon] = irandom_range(1, 10) * 100; dVal[ngon] = val[ngon]; bVal[ngon] = dVal[ngon]} // Increase polygon sides by one and resize arrays
if (mouse_check_button_pressed(mb_right))  {var index = irandom_range(0, ngon - 1); val[index] += 100; val[index] = clamp(val[index], 0, maxValue);} // Choose random index and increase it's value
if (mouse_check_button_pressed(mb_middle) || keyboard_check_pressed(ord("W"))) {fillAll = !fillAll;} // Switch fillAll mode
if (mouse_check_button_pressed(mb_middle) || keyboard_check_pressed(ord("A"))) {fillAll = -1;} // Switch fillAll mode

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
